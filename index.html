<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Contabilidad Simple v3.1 - Perfiles & Doble Respaldo</title>

<!-- SheetJS (XLSX) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>


<style>
  :root{
    --bg:#071127; --card:#071426; --accent:#7c3aed; --muted:#94a3b8; --glass: rgba(255,255,255,0.03);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial; background:linear-gradient(180deg,#030417 0%, #071127 60%), radial-gradient(800px 400px at 10% 10%, rgba(124,58,237,0.08), transparent); color:#e6eef8;}
  .container{max-width:1100px;margin:24px auto;padding:18px;}
  header{display:flex;gap:16px;align-items:center;justify-content:space-between}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:white;cursor:pointer;font-weight:600}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:16px;margin-top:18px}
  .card{background:var(--card);padding:14px;border-radius:12px;box-shadow: 0 6px 18px rgba(2,6,23,0.6)}
  form{display:flex;flex-direction:column;gap:8px}
  input,select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--glass);color:inherit}
  table{width:100%;border-collapse:collapse;color:#e6eef8}
  th,td{padding:8px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.03);font-size:13px}
  .small{font-size:13px;color:var(--muted)}
  .balance{font-size:28px;font-weight:700}
  .income{color:#6ee7b7} .expense{color:#fda4af}
  .loans{color:#fbbf24}
  .table-wrap{max-height:360px;overflow:auto;margin-top:10px}
  .footer{margin-top:14px;color:var(--muted);font-size:13px}
  .flex{display:flex;gap:8px;align-items:center}
  .grow{flex:1}
  .muted{color:var(--muted)}
  .file-info{font-size:13px;color:var(--muted)}
  .btn-icon{background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px;border-radius:6px}
  .editable{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px}
  /* Profiles UI */
  .profiles-area{display:flex;gap:8px;align-items:center;margin-left:12px}
  .global-summary{display:flex;gap:12px;align-items:center;margin-top:12px}
  .pill{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .pill .label{font-size:12px;color:var(--muted)}
  .pill .value{font-size:16px;font-weight:700}
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Contabilidad Simple ‚Äî v3.1 (Perfiles + Doble Respaldo)</h1>
        <div class="small muted">Edici√≥n inline ¬∑ Respaldo por perfil (IndexedDB) ¬∑ Excel local por perfil (.xlsx)</div>
        <!-- Bot√≥n para exportar Excel -->
        <button onclick="exportarExcel()">Exportar a Excel</button>
      </div>

      <div class="controls">
        <div class="file-info" id="fileStatus">Carpeta: <span class="muted">(ninguna)</span></div>
        <button id="chooseFolder" class="ghost">Seleccionar carpeta</button>
        <button id="openBtn">Abrir/Crear archivo (perfil)</button>
        <button id="exportBtn" class="ghost">Exportar manual (.xlsx)</button>
      </div>
    </header>

    <!-- Global summary (arriba de la grid) -->
    <div class="global-summary" role="region" aria-label="Resumen global">
      <div class="pill"><div class="label">Total Ingresos</div><div id="totalIngresos" class="value income">$0.00</div></div>
      <div class="pill"><div class="label">Total Gastos</div><div id="totalExpenses" class="value expense">$0.00</div></div>
      <div class="pill"><div class="label">Total Pr√©stamos</div><div id="totalLoans" class="value loans">$0.00</div></div>
      <div class="pill"><div class="label">Balance Global</div><div id="totalBalance" class="value">$0.00</div></div>

      <!-- Profiles quick control on the right -->
      <div style="margin-left:auto; display:flex;align-items:center;gap:8px">
        <div class="small">Perfil:</div>
        <div class="profiles-area">
          <select id="profileSelect"></select>
          <button id="newProfile" class="ghost">+ Perfil</button>
          <button id="renameProfile" class="ghost">Renombrar</button>
          <button id="deleteProfile" class="ghost">Eliminar</button>
        </div>
        <div style="margin-left:12px;text-align:right">
          <div class="small">√ölt. guardado:</div>
          <div id="lastSaved" class="muted">‚Äî</div>
        </div>
      </div>
    </div>

    <div class="grid">
      <div>
        <div class="card">
          <div class="flex" style="justify-content:space-between;align-items:center">
            <div>
              <div class="small">Balance actual (perfil activo)</div>
              <div class="balance" id="balance">$0.00</div>
              <div class="small">Ingresos: <span id="sumIncomes" class="income">$0.00</span> ‚Ä¢ Gastos: <span id="sumExpenses" class="expense">$0.00</span> ‚Ä¢ Pr√©stamos: <span id="sumLoans" class="loans">$0.00</span></div>
            </div>
            <div style="text-align:right">
              <div class="small">Perfil activo:</div>
              <div id="activeProfile" class="muted">‚Äî</div>
            </div>
          </div>

          <hr style="border:none;height:8px">

          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="newIncome">Nuevo Ingreso</button>
            <button id="newExpense" class="ghost">Nuevo Gasto</button>
            <button id="newLoan" class="ghost">Nuevo Pr√©stamo</button>
            <button id="clearAll" class="ghost" title="Borra todo (peligro)">Limpiar todo (perfil)</button>
          </div>

          <div style="margin-top:12px">
            <div class="small">Buscar / Filtrar</div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <input id="filterText" placeholder="Descripci√≥n o categor√≠a..." />
              <input id="fromDate" type="date" />
              <input id="toDate" type="date" />
              <button id="applyFilter" class="ghost">Aplicar</button>
              <button id="clearFilter" class="ghost">Quitar</button>
            </div>
          </div>

          <div class="table-wrap" id="tableWrap">
            <table id="entriesTable">
              <thead>
                <tr><th>Tipo</th><th>Descripci√≥n</th><th>Fecha</th><th>Categor√≠a</th><th>Monto</th><th></th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div class="footer">Respaldo por perfil en IndexedDB + Excel local en carpeta maestra. Si das permiso, la app actualizar√° autom√°ticamente el archivo .xlsx del perfil.</div>
        </div>
      </div>

      <aside>
        <div class="card">
          <div class="small">Formulario</div>
          <form id="entryForm">
            <select id="entryType">
              <option value="income">Ingreso</option>
              <option value="expense">Gasto</option>
              <option value="loan">Pr√©stamo</option>
            </select>
            <input id="desc" placeholder="Descripci√≥n (ej: venta X, compra Y)" required/>
            <input id="amount" type="number" step="0.01" placeholder="Monto" required/>
            <input id="date" type="date" required/>
            <input id="category" placeholder="Categor√≠a (ej: ventas, materiales)" />
            <div style="display:flex;gap:8px">
              <button id="saveEntry">Guardar</button>
              <button id="cancelEntry" type="button" class="ghost">Cancelar</button>
            </div>
          </form>

          <hr style="margin:12px 0;border:none;height:8px">
          <div class="small">Importar / Exportar</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <input id="fileInput" type="file" accept=".xlsx" />
            <button id="importBtn" class="ghost">Importar Excel</button>
          </div>
          <div style="margin-top:8px" class="small muted">Sugerencia: si no seleccionaste la carpeta maestra la primera vez, hazlo con 'Seleccionar carpeta'.</div>
        </div>
      </aside>
    </div>
  </div>

<script>
/* Contabilidad Simple v3.1
   - Perfiles + Doble respaldo (IndexedDB + Excel local en carpeta maestra)
   - Carpeta maestra persistente (se recuerda autom√°ticamente)
   - Archivo .xlsx por perfil (Ingresos, Gastos, Pr√©stamos)
   - Mantiene estilo visual v2.0
*/

(async function(){
  // --- MODELO ---
  let data = { entries: [] };            // current profile data
  let currentProfile = null;            // string (profile name)
  let currentBackupKey = null;          // 'backup::<profile>'
  const fileHandles = {};               // in-memory map profile -> fileHandle (FileSystemFileHandle)
  let dirHandle = null;                 // FileSystemDirectoryHandle (persisted to IndexedDB meta store)

  // DOM
  const el = id => document.getElementById(id);

  // IndexedDB: stores backups, profiles meta, meta (dir)
  const DB_NAME = 'contabilidad_db_v3_1';
  const BACKUP_STORE = 'backups';   // keyPath: key (eg 'backup::Name')
  const PROFILE_STORE = 'profiles'; // keyPath: name {name,fileName,updatedAt}
  const META_STORE = 'meta';        // keyPath: key (we store {key:'dir', handle: <dirHandle>})

  function openDb(){
    return new Promise((res,rej)=>{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = (e)=>{
        const db = e.target.result;
        if(!db.objectStoreNames.contains(BACKUP_STORE)) db.createObjectStore(BACKUP_STORE, {keyPath:'key'});
        if(!db.objectStoreNames.contains(PROFILE_STORE)) db.createObjectStore(PROFILE_STORE, {keyPath:'name'});
        if(!db.objectStoreNames.contains(META_STORE)) db.createObjectStore(META_STORE, {keyPath:'key'});
      };
      req.onsuccess = e => res(e.target.result);
      req.onerror = e => rej(e.target.error);
    });
  }
    // --- Login simple antes de cargar la app ---
(async function(){
  const users = { "admin":"1234", "user1":"abcd" }; // ejemplo de usuarios:usuario->contrase√±a
  let loggedIn = false;

  while(!loggedIn){
    const username = prompt("Usuario:");
    if(username === null) { alert("Acceso cancelado"); return; } // cancela todo
    const password = prompt("Contrase√±a:");
    if(password === null) { alert("Acceso cancelado"); return; }

    if(users[username] && users[username] === password){
      loggedIn = true;
      alert("¬°Bienvenido, " + username + "!");
    } else {
      alert("Usuario o contrase√±a incorrectos. Intenta nuevamente.");
    }
  }

  // --- Aqu√≠ comienza tu c√≥digo existente ---

  // --- Meta (dir) helpers ---
  async function saveDirHandleToDB(handle){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(META_STORE,'readwrite');
      tx.objectStore(META_STORE).put({ key: 'dir', handle });
      tx.oncomplete = ()=>res(true);
      tx.onerror = e=>rej(e.target.error);
    });
  }
  async function readDirHandleFromDB(){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(META_STORE,'readonly');
      const req = tx.objectStore(META_STORE).get('dir');
      req.onsuccess = ()=> res(req.result ? req.result.handle : null);
      req.onerror = e=>rej(e.target.error);
    });
  }
  async function clearDirHandleFromDB(){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(META_STORE,'readwrite');
      tx.objectStore(META_STORE).delete('dir');
      tx.oncomplete = ()=>res(true);
      tx.onerror = e=>rej(e.target.error);
    });
  }

  // --- Backups helpers ---
  async function saveBackup(key, payload){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(BACKUP_STORE,'readwrite');
      tx.objectStore(BACKUP_STORE).put({ key, payload, updatedAt: new Date().toISOString() });
      tx.oncomplete = ()=>res(true);
      tx.onerror = e => rej(e.target.error);
    });
  }
  async function readBackup(key){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(BACKUP_STORE,'readonly');
      const req = tx.objectStore(BACKUP_STORE).get(key);
      req.onsuccess = ()=> res(req.result ? req.result.payload : null);
      req.onerror = e => rej(e.target.error);
    });
  }
  async function readAllBackups(){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(BACKUP_STORE,'readonly');
      const req = tx.objectStore(BACKUP_STORE).getAll();
      req.onsuccess = ()=> res(req.result || []);
      req.onerror = e => rej(e.target.error);
    });
  }
  async function deleteBackup(key){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(BACKUP_STORE,'readwrite');
      tx.objectStore(BACKUP_STORE).delete(key);
      tx.oncomplete = ()=>res(true);
      tx.onerror = e=>rej(e.target.error);
    });
  }

  // --- Profiles meta helpers ---
  async function saveProfileMeta(meta){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(PROFILE_STORE,'readwrite');
      tx.objectStore(PROFILE_STORE).put(meta);
      tx.oncomplete = ()=>res(true);
      tx.onerror = e=>rej(e.target.error);
    });
  }
  async function readAllProfilesMeta(){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(PROFILE_STORE,'readonly');
      const req = tx.objectStore(PROFILE_STORE).getAll();
      req.onsuccess = ()=> res(req.result || []);
      req.onerror = e => rej(e.target.error);
    });
  }
  async function deleteProfileMeta(name){
    const db = await openDb();
    return new Promise((res,rej)=>{
      const tx = db.transaction(PROFILE_STORE,'readwrite');
      tx.objectStore(PROFILE_STORE).delete(name);
      tx.oncomplete = ()=>res(true);
      tx.onerror = e => rej(e.target.error);
    });
  }

  // --- Utility ---
  function formatMoney(n){ return new Intl.NumberFormat('es-CO',{style:'currency',currency:'USD',maximumFractionDigits:2}).format(n || 0); }
  function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;'); }
  function cryptoRandomId(){ if(window.crypto && crypto.randomUUID) return crypto.randomUUID(); return Math.random().toString(36).slice(2,10); }
  function formatDateFromExcel(val){
    if(typeof val === 'string' && /^\d{4}-\d{2}-\d{2}/.test(val)) return val.slice(0,10);
    if(typeof val === 'number'){ const d = XLSX.SSF.parse_date_code(val); if(d) return `${d.y}-${String(d.m).padStart(2,'0')}-${String(d.d).padStart(2,'0')}`; }
    const dt = new Date(val); if(!isNaN(dt)) return dt.toISOString().slice(0,10);
    return new Date().toISOString().slice(0,10);
  }

  // --- Directory selection & persistence ---
  async function chooseDirectory(){
    if(!window.showDirectoryPicker) {
      alert('Tu navegador no soporta selecci√≥n de carpetas (File System Access API). Usa Chrome o Edge.');
      return null;
    }
    try{
      const handle = await window.showDirectoryPicker();
      // persist handle in IndexedDB
      await saveDirHandleToDB(handle);
      dirHandle = handle;
      el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle.name || '(seleccionada)') + '</strong>';
      return handle;
    }catch(err){
      console.warn('chooseDirectory canceled or failed', err);
      return null;
    }
  }

  // Attempt to restore saved directory handle from DB (and verify permission)
  async function restoreSavedDirectory(){
    try{
      const saved = await readDirHandleFromDB();
      if(!saved) return null;
      // saved is a FileSystemDirectoryHandle (structured-cloneable in many browsers)
      // try query permission
      if(await verifyPermission(saved, true)){
        dirHandle = saved;
        el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle.name || '(guardada)') + '</strong>';
        return saved;
      } else {
        // try requesting permission
        const ok = await verifyPermission(saved, true);
        if(ok){
          dirHandle = saved;
          el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle.name || '(guardada)') + '</strong>';
          return saved;
        }
      }
    }catch(err){
      console.warn('restoreSavedDirectory err', err);
      return null;
    }
    return null;
  }

  // Verify permission helper
  async function verifyPermission(handle, withWrite){
    if(!handle) return false;
    try{
      // Some browsers implement query/request, others don't
      if(withWrite){
        if(handle.queryPermission){
          const q = await handle.queryPermission({mode:'readwrite'}); if(q === 'granted') return true;
        }
        if(handle.requestPermission){
          const r = await handle.requestPermission({mode:'readwrite'}); if(r === 'granted') return true;
        }
      } else {
        if(handle.queryPermission){
          const q = await handle.queryPermission({mode:'read'}); if(q === 'granted') return true;
        }
        if(handle.requestPermission){
          const r = await handle.requestPermission({mode:'read'}); if(r === 'granted') return true;
        }
      }
      // fallback: still allow (best-effort)
      return true;
    }catch(err){
      console.warn('verifyPermission err', err);
      return false;
    }
  }

  // --- Load files from directory into backups (on startup) ---
  async function importAllXlsxFromDirectory(){
    if(!dirHandle) return;
    try{
      for await (const entry of dirHandle.values()){
        if(entry.kind === 'file' && entry.name.toLowerCase().endsWith('.xlsx')){
          const profileName = entry.name.replace(/\.xlsx$/i,'');
          try{
            const file = await entry.getFile();
            const arr = await file.arrayBuffer();
            const wb = XLSX.read(arr, { type: 'array' });
            // We expect a sheet named 'entries' or separate sheets 'ingresos','gastos','prestamos'
            // To remain compatible with single-sheet v2 format, we'll look for 'entries' first
            let combinedEntries = [];
            if(wb.SheetNames.includes('entries')){
              const json = XLSX.utils.sheet_to_json(wb.Sheets['entries'], {defval:''});
              combinedEntries = json.map(row=>({
                id: cryptoRandomId(),
                type: (row.type||row.tipo||'').toString().toLowerCase() || 'expense',
                desc: row.desc||row.descripcion||'',
                amount: parseFloat(row.amount||row.monto||0) || 0,
                date: row.date ? formatDateFromExcel(row.date) : new Date().toISOString().slice(0,10),
                category: row.category||row.categoria||''
              }));
            } else {
              // try reading separate sheets and combine, preserving type
              const types = { ingresos: 'income', gastos: 'expense', prestamos: 'loan' };
              Object.keys(types).forEach(sheet => {
                if(wb.SheetNames.includes(sheet)){
                  const json = XLSX.utils.sheet_to_json(wb.Sheets[sheet], {defval:''});
                  json.forEach(row => {
                    combinedEntries.push({
                      id: cryptoRandomId(),
                      type: types[sheet],
                      desc: row.desc||row.descripcion||row.name||'',
                      amount: parseFloat(row.amount||row.monto||0) || 0,
                      date: row.date ? formatDateFromExcel(row.date) : new Date().toISOString().slice(0,10),
                      category: row.category||row.categoria||''
                    });
                  });
                }
              });
            }
            // save to backup if there are entries
            await saveBackup('backup::' + profileName, { entries: combinedEntries, updatedAt: new Date().toISOString() });
            // save profile meta (so it appears in select)
            await saveProfileMeta({ name: profileName, fileName: entry.name, updatedAt: new Date().toISOString() });
          }catch(err){
            console.warn('Error importing file', entry.name, err);
          }
        }
      }
    }catch(err){
      console.warn('importAllXlsxFromDirectory err', err);
    }
  }

  // --- Profiles UI / lifecycle ---
  async function loadProfilesIntoSelect(){
    const metas = await readAllProfilesMeta();
    // Also ensure we include profiles found as backups even if no meta
    const backups = await readAllBackups();
    backups.forEach(b => {
      const key = b.key;
      if(key && key.startsWith('backup::')){
        const name = key.replace(/^backup::/,'');
        if(!metas.find(m=>m.name===name)) metas.push({ name, fileName: null, updatedAt: b.updatedAt });
      }
    });

    const sel = el('profileSelect');
    sel.innerHTML = '';
    metas.forEach(p=>{
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.name;
      sel.appendChild(opt);
    });
    if(!currentProfile && metas.length>0){
      setActiveProfile(metas[0].name, false);
    } else if(currentProfile){
      sel.value = currentProfile;
    } else {
      sel.innerHTML = '<option value="">(ninguno)</option>';
      setActiveProfile(null, false);
    }
    await computeAndRenderGlobalSummary();
  }

  // Create new profile
  el('newProfile').addEventListener('click', async ()=>{
    const name = prompt('Nombre del nuevo perfil (ej: Restaurante 1):');
    if(!name) return;
    const metas = await readAllProfilesMeta();
    if(metas.find(m=>m.name === name)) return alert('Ya existe un perfil con ese nombre.');
    await saveProfileMeta({ name, fileName: null, updatedAt: new Date().toISOString() });
    await saveBackup('backup::' + name, { entries: [], updatedAt: new Date().toISOString() });
    await loadProfilesIntoSelect();
    setActiveProfile(name, true);
  });

  // Rename profile
  el('renameProfile').addEventListener('click', async ()=>{
    if(!currentProfile) return alert('Selecciona un perfil.');
    const nuevo = prompt('Nuevo nombre para el perfil', currentProfile);
    if(!nuevo || nuevo === currentProfile) return;
    // get backups & meta
    const metaList = await readAllProfilesMeta();
    const meta = metaList.find(m=>m.name===currentProfile) || { name: currentProfile, fileName: null };
    // move backup key: read, write under new key, delete old
    const bk = await readBackup('backup::' + currentProfile);
    if(bk){
      await saveBackup('backup::' + nuevo, bk);
      await deleteBackup('backup::' + currentProfile);
    } else {
      await saveBackup('backup::' + nuevo, { entries: [], updatedAt: new Date().toISOString() });
    }
    // update profile meta
    await saveProfileMeta({ name: nuevo, fileName: meta.fileName ? meta.fileName.replace(currentProfile, nuevo) : null, updatedAt: new Date().toISOString() });
    await deleteProfileMeta(currentProfile);
    // if file exists in dir, rename file in directory (best-effort)
    if(dirHandle){
      try{
        const oldName = (meta.fileName) ? meta.fileName : (currentProfile + '.xlsx');
        // try get old file handle
        const oldHandle = await dirHandle.getFileHandle(oldName).catch(()=>null);
        if(oldHandle){
          const newFilename = nuevo + '.xlsx';
          // create new file and copy content
          const fd = await oldHandle.getFile();
          const buf = await fd.arrayBuffer();
          const newHandle = await dirHandle.getFileHandle(newFilename, { create: true });
          const writable = await newHandle.createWritable();
          await writable.write(buf);
          await writable.close();
          // delete old file - many browsers do not support delete; best-effort using removeEntry if available
          if(dirHandle.removeEntry) {
            await dirHandle.removeEntry(oldName);
          }
          // update profile meta with new filename
          await saveProfileMeta({ name: nuevo, fileName: newFilename, updatedAt: new Date().toISOString() });
        }
      }catch(err){ console.warn('rename file in dir failed', err); }
    }
    await loadProfilesIntoSelect();
    setActiveProfile(nuevo, true);
  });

  // Delete profile
  el('deleteProfile').addEventListener('click', async ()=>{
    if(!currentProfile) return alert('Selecciona un perfil.');
    if(!confirm('Eliminar perfil "'+currentProfile+'"? Esto eliminar√° su respaldo local.')) return;
    // delete meta & backup
    await deleteProfileMeta(currentProfile);
    await deleteBackup('backup::' + currentProfile);
    // delete file in dir if exists
    try{
      if(dirHandle){
        const filename = currentProfile + '.xlsx';
        if(dirHandle.removeEntry) await dirHandle.removeEntry(filename).catch(()=>{});
      }
    }catch(err){ console.warn('delete file in dir failed', err); }
    currentProfile = null;
    currentBackupKey = null;
    await loadProfilesIntoSelect();
    // set first profile if exists
    const metas = await readAllProfilesMeta();
    if(metas.length>0) setActiveProfile(metas[0].name, true);
    else {
      data = { entries: [] };
      refreshUI();
    }
    await computeAndRenderGlobalSummary();
  });

  // When profile selected in UI
  el('profileSelect').addEventListener('change', (e)=>{
    const name = e.target.value;
    setActiveProfile(name, true);
  });

  // Set active profile
  async function setActiveProfile(name, focusUI = true){
    if(!name){
      currentProfile = null;
      currentBackupKey = null;
      data = { entries: [] };
      el('activeProfile').textContent = '‚Äî';
      refreshUI();
      return;
    }
    currentProfile = name;
    currentBackupKey = 'backup::' + name;
    el('activeProfile').textContent = name;
    // load backup if exists
    const bk = await readBackup(currentBackupKey);
    if(bk && bk.entries){
      data = bk;
      refreshUI();
    } else {
      // if no backup, but directory has file, import it
      if(dirHandle){
        try{
          const filename = name + '.xlsx';
          const fh = await dirHandle.getFileHandle(filename).catch(()=>null);
          if(fh){
            const file = await fh.getFile();
            const arr = await file.arrayBuffer();
            const wb = XLSX.read(arr, { type: 'array' });
            let combinedEntries = [];
            if(wb.SheetNames.includes('entries')){
              const json = XLSX.utils.sheet_to_json(wb.Sheets['entries'], {defval:''});
              combinedEntries = json.map(row=>({
                id: cryptoRandomId(),
                type: (row.type||row.tipo||'').toString().toLowerCase() || 'expense',
                desc: row.desc||row.descripcion||'',
                amount: parseFloat(row.amount||row.monto||0) || 0,
                date: row.date ? formatDateFromExcel(row.date) : new Date().toISOString().slice(0,10),
                category: row.category||row.categoria||''
              }));
            } else {
              const types = { ingresos: 'income', gastos: 'expense', prestamos: 'loan' };
              Object.keys(types).forEach(sheet => {
                if(wb.SheetNames.includes(sheet)){
                  const json = XLSX.utils.sheet_to_json(wb.Sheets[sheet], {defval:''});
                  json.forEach(row => {
                    combinedEntries.push({
                      id: cryptoRandomId(),
                      type: types[sheet],
                      desc: row.desc||row.descripcion||row.name||'',
                      amount: parseFloat(row.amount||row.monto||0) || 0,
                      date: row.date ? formatDateFromExcel(row.date) : new Date().toISOString().slice(0,10),
                      category: row.category||row.categoria||''
                    });
                  });
                }
              });
            }
            data = { entries: combinedEntries };
            await saveBackup(currentBackupKey, data);
            await saveProfileMeta({ name: currentProfile, fileName: filename, updatedAt: new Date().toISOString() });
            refreshUI();
          } else {
            // initialize empty
            data = { entries: [] };
            await saveBackup(currentBackupKey, data);
            refreshUI();
          }
        }catch(err){ console.warn('setActiveProfile read file err', err); data = { entries: [] }; refreshUI(); }
      } else {
        data = { entries: [] };
        await saveBackup(currentBackupKey, data);
        refreshUI();
      }
    }
    // update fileStatus to show assigned file if any
    const metas = await readAllProfilesMeta();
    const meta = metas.find(m=>m.name === currentProfile);
    if(meta && meta.fileName) el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle ? dirHandle.name : '') + '</strong> ‚Ä¢ Archivo: <strong>' + meta.fileName + '</strong>';
    else el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle ? dirHandle.name : '(ninguna)') + '</strong>';
    // persist last opened profile
    if(name) localStorage.setItem('last_opened_profile', name);
    await computeAndRenderGlobalSummary();
  }

  // --- Directory & file assignment UI handlers ---
  el('chooseFolder').addEventListener('click', async ()=>{
    const picked = await chooseDirectory();
    if(picked){
      // import files from dir and rebuild backups for those files
      await importAllXlsxFromDirectory();
      await loadProfilesIntoSelect();
      alert('Carpeta maestra guardada: ' + (dirHandle.name || 'selected'));
    } else {
      alert('No se seleccion√≥ carpeta.');
    }
  });

  // On open/create file for current profile (assigns fileHandle in-memory and creates file in dir)
  el('openBtn').addEventListener('click', async ()=>{
    if(!currentProfile) return alert('Selecciona un perfil antes de abrir/crear un archivo.');
    // Ensure folder chosen
    if(!dirHandle){
      const ok = confirm('No hay carpeta maestra seleccionada. ¬øDeseas elegirla ahora?');
      if(!ok) return;
      const picked = await chooseDirectory();
      if(!picked) return;
      // import files
      await importAllXlsxFromDirectory();
      await loadProfilesIntoSelect();
    }
    // create/get file handle inside the directory
    try{
      const filename = currentProfile + '.xlsx';
      const fh = await dirHandle.getFileHandle(filename, { create: true });
      fileHandles[currentProfile] = fh;
      await saveProfileMeta({ name: currentProfile, fileName: filename, updatedAt: new Date().toISOString() });
      el('fileStatus').innerHTML = 'Carpeta: <strong>' + dirHandle.name + '</strong> ‚Ä¢ Archivo: <strong>' + filename + '</strong>';
      // write current data to file immediately
      await persistAll();
      alert('Archivo asignado y guardado para el perfil: ' + filename);
    }catch(err){
      console.warn('openBtn error', err);
      alert('No se pudo asignar archivo en la carpeta seleccionada.');
    }
  });

  // --- Core CRUD (per-profile) based on v2 behavior ---
  function refreshUI(filtered=null){
    const arr = (filtered || data.entries.slice()).sort((a,b)=> new Date(b.date) - new Date(a.date));
    const tbody = document.querySelector('#entriesTable tbody');
    tbody.innerHTML = '';
    let sumIn=0,sumEx=0,sumLoans=0;
    for(const r of arr){
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="${r.type === 'income' ? 'income' : r.type === 'expense' ? 'expense' : 'loans'}">${r.type}</td>
        <td><div class="editable" contenteditable="false" data-field="desc" data-id="${r.id}">${escapeHtml(r.desc)}</div></td>
        <td><div class="editable" contenteditable="false" data-field="date" data-id="${r.id}">${r.date}</div></td>
        <td><div class="editable" contenteditable="false" data-field="category" data-id="${r.id}">${escapeHtml(r.category||'')}</div></td>
        <td><div class="editable" contenteditable="false" data-field="amount" data-id="${r.id}">${r.amount.toFixed(2)}</div></td>
        <td>
          <button class="btn-icon edit" data-id="${r.id}">‚úèÔ∏è</button>
          <button class="btn-icon save" data-id="${r.id}" style="display:none">üíæ</button>
          <button class="btn-icon cancel" data-id="${r.id}" style="display:none">‚úñ</button>
          <button class="btn-icon del ghost" data-id="${r.id}">üóë</button>
        </td>
      `;
      tbody.appendChild(tr);
      if(r.type==='income') sumIn += r.amount;
      if(r.type==='expense') sumEx += r.amount;
      if(r.type==='loan') sumLoans += r.amount;
    }
    el('sumIncomes').textContent = formatMoney(sumIn);
    el('sumExpenses').textContent = formatMoney(sumEx);
    el('sumLoans').textContent = formatMoney(sumLoans);
    el('balance').textContent = formatMoney(sumIn - sumEx);
  }

  function addEntry(obj){
    if(!currentProfile) return alert('Selecciona un perfil primero (arriba).');
    obj.id = cryptoRandomId(); obj.amount = Number(obj.amount)||0; data.entries.push(obj);
    scheduleSave(); refreshUI();
  }
  function updateEntry(id, fields){ const idx = data.entries.findIndex(x=>x.id===id); if(idx>-1){ Object.assign(data.entries[idx], fields); scheduleSave(); refreshUI(); }}
  function removeEntry(id){ data.entries = data.entries.filter(x=>x.id!==id); scheduleSave(); refreshUI(); }

  // events (edit/save/cancel/delete)
  document.addEventListener('click', (ev)=>{
    if(ev.target.matches('.del')){
      const id = ev.target.dataset.id; if(confirm('Eliminar registro?')) removeEntry(id);
    }
    if(ev.target.matches('.edit')){
      const id = ev.target.dataset.id; toggleEditMode(id, true);
    }
    if(ev.target.matches('.save')){
      const id = ev.target.dataset.id; applyEditSave(id);
    }
    if(ev.target.matches('.cancel')){
      const id = ev.target.dataset.id; toggleEditMode(id, false, true);
    }
  });

  function toggleEditMode(id, on, cancel=false){
    const rowEls = document.querySelectorAll('[data-id="'+id+'"]');
    rowEls.forEach(elm=>{
      if(elm.classList.contains('editable')){
        elm.contentEditable = on;
        if(on) elm.focus();
        elm.style.outline = on ? '1px dashed rgba(124,58,237,0.5)' : 'none';
      }
      const tr = elm.closest('tr');
      if(tr){
        tr.querySelector('.edit').style.display = on ? 'none' : '';
        tr.querySelector('.save').style.display = on ? '' : 'none';
        tr.querySelector('.cancel').style.display = on ? '' : 'none';
      }
    });
    if(cancel){
      const entry = data.entries.find(x=>x.id===id);
      if(entry){
        document.querySelectorAll('[data-id="'+id+'"]').forEach(elm=>{
          const field = elm.dataset.field; if(field) elm.textContent = field==='amount' ? entry.amount.toFixed(2) : (entry[field]||'');
        });
      }
    }
  }

  function applyEditSave(id){
    const entry = data.entries.find(x=>x.id===id);
    if(!entry) return;
    const updates = {};
    document.querySelectorAll('[data-id="'+id+'"]').forEach(elm=>{
      const f = elm.dataset.field; if(!f) return;
      let val = elm.textContent.trim();
      if(f==='amount') val = parseFloat(val.replace(/[^0-9.-]+/g,'')) || 0;
      updates[f] = val;
    });
    if(updates.amount !== undefined) updates.amount = Number(updates.amount)||0;
    updateEntry(id, updates);
  }

  // form handlers
  el('newIncome').addEventListener('click', ()=> openForm('income'));
  el('newExpense').addEventListener('click', ()=> openForm('expense'));
  el('newLoan').addEventListener('click', ()=> openForm('loan'));
  el('cancelEntry').addEventListener('click', ()=> el('entryForm').reset());

  function openForm(type){ el('entryType').value = type; el('date').value = new Date().toISOString().slice(0,10); el('amount').value=''; el('desc').value=''; el('category').value=''; el('desc').focus(); }

  el('entryForm').addEventListener('submit', (ev)=>{
    ev.preventDefault();
    const obj = { type: el('entryType').value, desc: el('desc').value||'', amount: parseFloat(el('amount').value)||0, date: el('date').value, category: el('category').value||'' };
    addEntry(obj);
    el('entryForm').reset();
  });

  // filters
  el('applyFilter').addEventListener('click', ()=>{
    const text = el('filterText').value.toLowerCase().trim();
    const from = el('fromDate').value; const to = el('toDate').value;
    const filtered = data.entries.filter(r=>{
      if(text){ const ok = (r.desc||'').toLowerCase().includes(text) || (r.category||'').toLowerCase().includes(text); if(!ok) return false; }
      if(from && new Date(r.date) < new Date(from)) return false;
      if(to && new Date(r.date) > new Date(to)) return false;
      return true;
    }); refreshUI(filtered);
  });
  el('clearFilter').addEventListener('click', ()=>{ el('filterText').value=''; el('fromDate').value=''; el('toDate').value=''; refreshUI(); });

  // import -> active profile
  el('importBtn').addEventListener('click', async ()=>{
    const f = el('fileInput').files[0]; if(!f){ alert('Selecciona un archivo .xlsx'); return; }
    if(!currentProfile) return alert('Selecciona un perfil para importar');
    try{
      const arr = await f.arrayBuffer(); const wb = XLSX.read(arr,{type:'array'});
      const sheetName = wb.SheetNames.includes('entries') ? 'entries' : wb.SheetNames[0];
      const json = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {defval:''});
      const imported = json.map(row=>({ id: cryptoRandomId(), type: (row.type||row.tipo||'').toString().toLowerCase()||'expense', desc: row.desc||row.descripcion||'', amount: parseFloat(row.amount||row.monto||0)||0, date: row.date ? formatDateFromExcel(row.date) : new Date().toISOString().slice(0,10), category: row.category||row.categoria||'' }));
      data.entries = data.entries.concat(imported);
      scheduleSave();
      refreshUI();
      alert('Importado '+imported.length+' filas al perfil '+currentProfile);
    }catch(err){ console.error(err); alert('Error al importar: '+err.message); }
  });

  // export manual (active profile)
  el('exportBtn').addEventListener('click', ()=> saveWorkbook(true));

  // clear all (profile)
  el('clearAll').addEventListener('click', ()=>{ if(!currentProfile) return alert('Selecciona un perfil.'); if(!confirm('¬øBorrar todos los registros de este perfil?')) return; data.entries = []; scheduleSave(); refreshUI(); });

  // save workbook (writes file inside dir if assigned, else fallback download)
  async function saveWorkbook(isManual=false){
    if(!currentProfile) return;
    const rows = data.entries.map(e=>({ type:e.type, desc:e.desc, date:e.date, category:e.category, amount:e.amount }));
    // we'll write a single sheet 'entries' for compatibility
    const ws = XLSX.utils.json_to_sheet(rows);
    const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, 'entries');
    const wbout = XLSX.write(wb, {bookType:'xlsx', type:'array'});

    // If dirHandle exists, write to file within directory (create or overwrite)
    if(dirHandle){
      try{
        const filename = currentProfile + '.xlsx';
        const fh = await dirHandle.getFileHandle(filename, { create: true });
        const writable = await fh.createWritable();
        await writable.write(new Blob([wbout], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}));
        await writable.close();
        // update profile meta
        await saveProfileMeta({ name: currentProfile, fileName: filename, updatedAt: new Date().toISOString() });
        el('lastSaved').textContent = new Date().toLocaleString();
        el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle ? dirHandle.name : '') + '</strong> ‚Ä¢ Archivo: <strong>' + filename + '</strong>';
        return;
      }catch(err){
        console.warn('Error escribiendo en carpeta:', err);
      }
    }

    // fallback: download
    try{
      const blob = new Blob([wbout], {type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url;
      const filename = 'contabilidad-' + currentProfile + '.xlsx';
      a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      if(isManual) alert('Exportado: ' + filename);
      await saveProfileMeta({ name: currentProfile, fileName: filename, updatedAt: new Date().toISOString() });
      el('lastSaved').textContent = new Date().toLocaleString();
    }catch(err){ console.error('Error en fallback export', err); }
  }

  // persist current profile: save to DB and attempt write to file
  async function persistAll(){
    if(!currentProfile) return;
    const payload = { entries: data.entries.slice(), updatedAt: new Date().toISOString() };
    try{
      await saveBackup(currentBackupKey, payload);
      // also update profile meta
      const metas = await readAllProfilesMeta();
      const meta = metas.find(m => m.name === currentProfile);
      const newMeta = { name: currentProfile, fileName: meta ? meta.fileName : (dirHandle ? (currentProfile + '.xlsx') : null), updatedAt: new Date().toISOString() };
      await saveProfileMeta(newMeta);
    }catch(err){ console.warn('Error guardando backup local:', err); }
    try{ await saveWorkbook(false); }catch(err){ console.warn('No se pudo escribir a Excel:', err); }
    el('lastSaved').textContent = new Date().toLocaleString();
    await computeAndRenderGlobalSummary();
  }

  // debounce auto-save
  let saveTimer = null;
  function scheduleSave(){
    if(saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(async ()=>{
      saveTimer = null;
      try{ await persistAll(); }catch(e){ console.warn('persistAll err', e); }
    }, 900);
  }

  // compute global summary by reading all backups (Option A)
  async function computeAndRenderGlobalSummary(){
    try{
      const all = await readAllBackups();
      let tin=0,tout=0,tloan=0;
      all.forEach(item => {
        const payload = item && item.payload ? item.payload : (item.payload === null ? null : item);
        if(!payload || !payload.entries) return;
        payload.entries.forEach(e => {
          if(e.type === 'income') tin += Number(e.amount || 0);
          else if(e.type === 'expense') tout += Number(e.amount || 0);
          else if(e.type === 'loan') tloan += Number(e.amount || 0);
        });
      });
      el('totalIngresos').textContent = formatMoney(tin);
      el('totalExpenses').textContent = formatMoney(tout);
      el('totalLoans').textContent = formatMoney(tloan);
      el('totalBalance').textContent = formatMoney(tin - tout);
    }catch(err){
      console.warn('computeAndRenderGlobalSummary err', err);
    }
  }

  // --- Startup / restore flow ---
  async function tryRestoreEverything(){
    // 1) try restore a saved dir handle
    const savedDir = await readDirHandleFromDB();
    if(savedDir){
      // try verify permission (best-effort)
      if(await verifyPermission(savedDir, true)){
        dirHandle = savedDir;
        el('fileStatus').innerHTML = 'Carpeta: <strong>' + (dirHandle.name || '(guardada)') + '</strong>';
        // import files found in directory into backups
        await importAllXlsxFromDirectory();
      } else {
        // request explicit selection if permission not granted
        try{
          const picked = await chooseDirectory();
          if(picked) {
            await importAllXlsxFromDirectory();
          }
        }catch(e){ console.warn('permission request canceled', e); }
      }
    } else {
      // no saved dir; ask user (first-time) as requested
      try{
        const want = confirm('¬øDeseas seleccionar ahora la carpeta maestra donde se guardar√°n los archivos .xlsx de los perfiles? (Se recordar√° autom√°ticamente)');
        if(want){
          const picked = await chooseDirectory();
          if(picked){
            await importAllXlsxFromDirectory();
          }
        }
      }catch(e){ console.warn('choose folder canceled', e); }
    }

    // 2) load profiles (from meta and from backups)
    await loadProfilesIntoSelect();

    // 3) restore last opened profile if any
    const lastProfile = localStorage.getItem('last_opened_profile');
    if(lastProfile){
      const metas = await readAllProfilesMeta();
      if(metas.find(m=>m.name === lastProfile)) setActiveProfile(lastProfile, true);
    }
    // 4) compute global
    await computeAndRenderGlobalSummary();
  }

  // Final boot actions
  await tryRestoreEverything();

  // If no profile exists create default
  const metasNow = await readAllProfilesMeta();
  if(metasNow.length === 0){
    const defaultName = 'MiNegocio';
    await saveProfileMeta({ name: defaultName, fileName: null, updatedAt: new Date().toISOString() });
    await saveBackup('backup::' + defaultName, { entries: [], updatedAt: new Date().toISOString() });
    await loadProfilesIntoSelect();
    setActiveProfile(defaultName, true);
  }

  // Expose debug tools
  window._contAppV31 = {
    getActiveProfile: () => currentProfile,
    getData: () => data,
    listProfiles: async () => await readAllProfilesMeta(),
    listBackups: async () => await readAllBackups(),
    getDirHandle: async () => dirHandle
  };
})();
})();
</script>
</script>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
</body>
</html>
